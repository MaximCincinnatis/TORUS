#!/usr/bin/env node

/**
 * Updates LP Fee Burns (buy-process-burns.json) with protocol day calculations
 * This tracks fee collections from LP that drive TORUS burns
 */

const { ethers } = require('ethers');
const fs = require('fs');
const path = require('path');

// RPC endpoints
const RPC_ENDPOINTS = [
  'https://eth.drpc.org',
  'https://ethereum.publicnode.com',
  'https://eth.llamarpc.com'
];

async function updateLPFeeBurns() {
  console.log('üî• Updating LP Fee Burns data with protocol days...\n');
  
  try {
    const provider = new ethers.providers.JsonRpcProvider(RPC_ENDPOINTS[0]);
    const BUY_PROCESS_CONTRACT = '0xaa390a37006e22b5775a34f2147f81ebd6a63641';
    
    // Contract start date (6 PM UTC - actual protocol start time)
    const CONTRACT_START_DATE = new Date('2025-07-10T18:00:00.000Z');
    
    // Helper function to calculate protocol day from date
    function getProtocolDay(date) {
      const msPerDay = 24 * 60 * 60 * 1000;
      let dateObj;
      
      if (typeof date === 'string') {
        // For date strings like "2025-07-12", assume 12:00 UTC (noon) to avoid timezone issues
        dateObj = new Date(date + 'T12:00:00.000Z');
      } else {
        dateObj = date;
      }
      
      const daysDiff = Math.floor((dateObj.getTime() - CONTRACT_START_DATE.getTime()) / msPerDay) + 1;
      return Math.max(1, daysDiff);
    }
    
    // Load existing data
    const dataPath = path.join(__dirname, '../public/data/buy-process-burns.json');
    let existingData = null;
    
    if (fs.existsSync(dataPath)) {
      existingData = JSON.parse(fs.readFileSync(dataPath, 'utf8'));
      console.log('Loaded existing LP fee burns data');
      console.log(`Found ${existingData.feeDrivenBurns?.length || 0} existing fee burn records`);
      
      // Update existing records with protocol days
      if (existingData.feeDrivenBurns) {
        existingData.feeDrivenBurns = existingData.feeDrivenBurns.map(burn => {
          const protocolDay = getProtocolDay(new Date(burn.date));
          return {
            ...burn,
            protocolDay
          };
        });
        
        // Sort by protocol day
        existingData.feeDrivenBurns.sort((a, b) => a.protocolDay - b.protocolDay);
      }
      
      // Update the lastUpdated timestamp
      existingData.lastUpdated = new Date().toISOString();
      
      // Save updated data
      fs.writeFileSync(dataPath, JSON.stringify(existingData, null, 2));
      
      console.log(`\n‚úÖ LP Fee Burns data updated successfully`);
      console.log(`üìä Total fee collections: ${existingData.totals?.feeCollections || 0}`);
      console.log(`üî• Total TORUS burned from fees: ${existingData.totals?.torusBurned || 0} TORUS`);
      
      // Show protocol day mapping
      if (existingData.feeDrivenBurns?.length > 0) {
        console.log('\nüìÖ Protocol Day Mapping:');
        existingData.feeDrivenBurns.forEach(burn => {
          const date = new Date(burn.date).toISOString().split('T')[0];
          console.log(`  Day ${burn.protocolDay}: ${date} - ${parseFloat(burn.torusBurned).toFixed(2)} TORUS burned`);
        });
      }
    } else {
      console.log('No existing LP fee burns data found. This data is typically generated by another process.');
      console.log('Creating placeholder file...');
      
      const placeholderData = {
        lastUpdated: new Date().toISOString(),
        lastBlock: await provider.getBlockNumber(),
        nftPosition: {
          tokenId: 1029195,
          owner: BUY_PROCESS_CONTRACT
        },
        feeDrivenBurns: [],
        totals: {
          feeCollections: 0,
          torusCollected: "0",
          torusBurned: "0",
          titanxCollected: "0",
          averageBurnRate: "0"
        }
      };
      
      fs.writeFileSync(dataPath, JSON.stringify(placeholderData, null, 2));
      console.log('Created placeholder buy-process-burns.json file');
    }
    
  } catch (error) {
    console.error('‚ùå Error updating LP Fee Burns data:', error);
    process.exit(1);
  }
}

// Run the update
updateLPFeeBurns();